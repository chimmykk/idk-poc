/**
 * PVAC-HFHE Division Vulnerability Exploit
 *
 * Exploits the seed reuse in ct_div_const to recover the divisor
 */

#include <iostream>
#include <vector>
#include <fstream>
#include <cstring>

#include "../include/pvac/pvac.hpp"

using namespace pvac;

// IO helpers
namespace io {
    auto get32 = [](std::istream& i) -> uint32_t {
        uint32_t x = 0; i.read(reinterpret_cast<char*>(&x), 4); return x;
    };
    auto get64 = [](std::istream& i) -> uint64_t {
        uint64_t x = 0; i.read(reinterpret_cast<char*>(&x), 8); return x;
    };
    auto getBv = [](std::istream& i) -> BitVec {
        auto b = BitVec::make((int)get32(i));
        for (size_t j = 0; j < (b.nbits + 63) / 64; ++j) b.w[j] = get64(i);
        return b;
    };
    auto getFp = [](std::istream& i) -> Fp {
        return {get64(i), get64(i)};
    };
}

namespace ser {
    using namespace io;
    auto getLayer = [](std::istream& i) -> Layer {
        Layer L{};
        L.rule = (RRule)i.get();
        if (L.rule == RRule::BASE) {
            L.seed.ztag = get64(i);
            L.seed.nonce.lo = get64(i);
            L.seed.nonce.hi = get64(i);
        } else if (L.rule == RRule::PROD) {
            L.pa = get32(i);
            L.pb = get32(i);
        } else {
            (void)get64(i); (void)get64(i); (void)get64(i);
        }
        return L;
    };
    auto getEdge = [](std::istream& i) -> Edge {
        Edge e{};
        e.layer_id = get32(i);
        i.read(reinterpret_cast<char*>(&e.idx), 2);
        e.ch = (uint8_t)i.get();
        i.get();
        e.w = getFp(i);
        e.s = getBv(i);
        return e;
    };
    auto getCipher = [](std::istream& i) -> Cipher {
        Cipher C;
        auto nL = get32(i), nE = get32(i);
        C.L.resize(nL); C.E.resize(nE);
        for (auto& L : C.L) L = getLayer(i);
        for (auto& e : C.E) e = getEdge(i);
        return C;
    };
}

namespace Magic {
    constexpr uint32_t CT = 0x66699666;
    constexpr uint32_t PK = 0x06660666;
    constexpr uint32_t VER = 1;
}

auto loadCts = [](const std::string& path) -> std::vector<Cipher> {
    std::ifstream i(path, std::ios::binary);
    if (!i || io::get32(i) != Magic::CT || io::get32(i) != Magic::VER)
        throw std::runtime_error("bad CT: " + path);
    std::vector<Cipher> cts(io::get64(i));
    for (auto& c : cts) c = ser::getCipher(i);
    return cts;
};

auto loadPk = [](const std::string& path) -> PubKey {
    std::ifstream i(path, std::ios::binary);
    if (!i || io::get32(i) != Magic::PK || io::get32(i) != Magic::VER)
        throw std::runtime_error("bad PK: " + path);
    PubKey pk;
    pk.prm.m_bits = io::get32(i);
    pk.prm.B = io::get32(i);
    pk.prm.lpn_t = io::get32(i);
    pk.prm.lpn_n = io::get32(i);
    pk.prm.lpn_tau_num = io::get32(i);
    pk.prm.lpn_tau_den = io::get32(i);
    pk.prm.noise_entropy_bits = io::get32(i);
    pk.prm.depth_slope_bits = io::get32(i);
    uint64_t t2 = io::get64(i);
    std::memcpy(&pk.prm.tuple2_fraction, &t2, 8);
    pk.prm.edge_budget = io::get32(i);
    pk.canon_tag = io::get64(i);
    i.read(reinterpret_cast<char*>(pk.H_digest.data()), 32);
    pk.H.resize(io::get64(i));
    for (auto& h : pk.H) h = io::getBv(i);
    pk.ubk.perm.resize(io::get64(i));
    for (auto& v : pk.ubk.perm) v = io::get32(i);
    pk.ubk.inv.resize(io::get64(i));
    for (auto& v : pk.ubk.inv) v = io::get32(i);
    pk.omega_B = io::getFp(i);
    pk.powg_B.resize(io::get64(i));
    for (auto& f : pk.powg_B) f = io::getFp(i);
    return pk;
};

Fp layer_gsum(const PubKey& pk, const Cipher& C, uint32_t layer_id) {
    Fp acc = fp_from_u64(0);
    for (const auto& e : C.E) {
        if (e.layer_id == layer_id) {
            Fp term = fp_mul(e.w, pk.powg_B[e.idx]);
            if (e.ch == SGN_P) acc = fp_add(acc, term);
            else acc = fp_sub(acc, term);
        }
    }
    return acc;
}

Fp total_gsum(const PubKey& pk, const Cipher& C) {
    Fp acc = fp_from_u64(0);
    for (const auto& e : C.E) {
        Fp term = fp_mul(e.w, pk.powg_B[e.idx]);
        if (e.ch == SGN_P) acc = fp_add(acc, term);
        else acc = fp_sub(acc, term);
    }
    return acc;
}

void print_fp(const char* label, const Fp& x) {
    printf("%s: lo=0x%016llx hi=0x%016llx (decimal: %llu)\n", label,
           (unsigned long long)x.lo, (unsigned long long)x.hi,
           (unsigned long long)x.lo);
}

bool fp_equal(const Fp& a, const Fp& b) {
    return a.lo == b.lo && a.hi == b.hi;
}

void analyze_structure(const char* name, const Cipher& C) {
    printf("[%s] L=%zu E=%zu\n", name, C.L.size(), C.E.size());
}

void exploit_division_vulnerability(const PubKey& pk, const Cipher& ct_a, const Cipher& ct_div) {
    printf("\n--- Exploit: Seed Reuse ---\n");

    if (ct_a.L.size() != ct_div.L.size()) {
        printf("Error: Layer size mismatch.\n");
        return;
    }

    bool seeds_match = true;
    for (size_t i = 0; i < ct_a.L.size(); i++) {
        if (ct_a.L[i].rule == RRule::BASE && ct_div.L[i].rule == RRule::BASE) {
            bool match = (ct_a.L[i].seed.ztag == ct_div.L[i].seed.ztag) &&
                        (ct_a.L[i].seed.nonce.lo == ct_div.L[i].seed.nonce.lo) &&
                        (ct_a.L[i].seed.nonce.hi == ct_div.L[i].seed.nonce.hi);
            seeds_match = seeds_match && match;
        }
    }

    if (!seeds_match) {
        printf("Warning: Seeds differ.\n");
    } else {
        printf("Vulnerability: Seed reuse confirmed.\n");
    }

    std::vector<Fp> rv_a, rv_div;
    for (size_t layer_id = 0; layer_id < ct_a.L.size(); layer_id++) {
        rv_a.push_back(layer_gsum(pk, ct_a, layer_id));
        rv_div.push_back(layer_gsum(pk, ct_div, layer_id));
    }

    printf("\n--- Recovering Divisor ---\n");
    Fp recovered = {0, 0};
    bool found = false;

    for (size_t i = 0; i < rv_a.size(); i++) {
        if (rv_div[i].lo == 0 && rv_div[i].hi == 0) continue;

        Fp k_rec = fp_mul(rv_a[i], fp_inv(rv_div[i]));
        if (!found) { recovered = k_rec; found = true; }
        
        printf("Layer %zu k: %llu\n", i, (unsigned long long)k_rec.lo);
    }

    if (found) {
        printf("\nResult k: %llu\n", (unsigned long long)recovered.lo);
    }
}

void run_algebraic_tests(const PubKey& pk, const Cipher& ct_a, const Cipher& ct_b) {
    Fp g_a = total_gsum(pk, ct_a);
    Fp g_b = total_gsum(pk, ct_b);

    Cipher ct_sum = ct_add(pk, ct_a, ct_b);
    Fp g_sum = total_gsum(pk, ct_sum);
    Fp g_exp = fp_add(g_a, g_b);

    printf("\nTest Add: %s\n", fp_equal(g_sum, g_exp) ? "OK" : "FAIL");
}

int main() {
    try {
        PubKey pk = loadPk("bounty3_data/pk.bin");
        Cipher ct_a = loadCts("bounty3_data/a.ct")[0];
        Cipher ct_b = loadCts("bounty3_data/b.ct")[0];
        Cipher ct_div = loadCts("bounty3_data/divresult.ct")[0];

        analyze_structure("a.ct", ct_a);
        analyze_structure("divresult.ct", ct_div);

        exploit_division_vulnerability(pk, ct_a, ct_div);
        run_algebraic_tests(pk, ct_a, ct_b);

    } catch (const std::exception& e) {
        fprintf(stderr, "Error: %s\n", e.what());
        return 1;
    }
    return 0;
}
